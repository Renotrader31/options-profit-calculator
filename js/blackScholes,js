/**
 * Black-Scholes Options Pricing Model Implementation
 * Provides accurate options pricing and Greeks calculations
 */

class BlackScholes {
    /**
     * Calculate cumulative standard normal distribution
     * @param {number} x - Input value
     * @returns {number} - Cumulative probability
     */
    static normalCDF(x) {
        // Abramowitz and Stegun approximation
        const sign = x >= 0 ? 1 : -1;
        x = Math.abs(x) / Math.sqrt(2);
        
        const a1 =  0.254829592;
        const a2 = -0.284496736;
        const a3 =  1.421413741;
        const a4 = -1.453152027;
        const a5 =  1.061405429;
        const p  =  0.3275911;
        
        const t = 1.0 / (1.0 + p * x);
        const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
        
        return 0.5 * (1.0 + sign * y);
    }

    /**
     * Calculate standard normal probability density function
     * @param {number} x - Input value
     * @returns {number} - Probability density
     */
    static normalPDF(x) {
        return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
    }

    /**
     * Calculate d1 parameter for Black-Scholes formula
     * @param {number} S - Current stock price
     * @param {number} K - Strike price
     * @param {number} T - Time to expiration (in years)
     * @param {number} r - Risk-free rate
     * @param {number} sigma - Volatility
     * @returns {number} - d1 value
     */
    static calculateD1(S, K, T, r, sigma) {
        return (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
    }

    /**
     * Calculate d2 parameter for Black-Scholes formula
     * @param {number} d1 - d1 value
     * @param {number} sigma - Volatility
     * @param {number} T - Time to expiration (in years)
     * @returns {number} - d2 value
     */
    static calculateD2(d1, sigma, T) {
        return d1 - sigma * Math.sqrt(T);
    }

    /**
     * Calculate call option price using Black-Scholes formula
     * @param {number} S - Current stock price
     * @param {number} K - Strike price
     * @param {number} T - Time to expiration (in years)
     * @param {number} r - Risk-free rate
     * @param {number} sigma - Volatility
     * @returns {number} - Call option price
     */
    static callPrice(S, K, T, r, sigma) {
        if (T <= 0) return Math.max(S - K, 0);
        
        const d1 = this.calculateD1(S, K, T, r, sigma);
        const d2 = this.calculateD2(d1, sigma, T);
        
        const callPrice = S * this.normalCDF(d1) - K * Math.exp(-r * T) * this.normalCDF(d2);
        return Math.max(callPrice, 0);
    }

    /**
     * Calculate put option price using Black-Scholes formula
     * @param {number} S - Current stock price
     * @param {number} K - Strike price
     * @param {number} T - Time to expiration (in years)
     * @param {number} r - Risk-free rate
     * @param {number} sigma - Volatility
     * @returns {number} - Put option price
     */
    static putPrice(S, K, T, r, sigma) {
        if (T <= 0) return Math.max(K - S, 0);
        
        const d1 = this.calculateD1(S, K, T, r, sigma);
        const d2 = this.calculateD2(d1, sigma, T);
        
        const putPrice = K * Math.exp(-r * T) * this.normalCDF(-d2) - S * this.normalCDF(-d1);
        return Math.max(putPrice, 0);
    }

    /**
     * Calculate option Greeks
     * @param {number} S - Current stock price
     * @param {number} K - Strike price
     * @param {number} T - Time to expiration (in years)
     * @param {number} r - Risk-free rate
     * @param {number} sigma - Volatility
     * @param {string} optionType - 'call' or 'put'
     * @returns {Object} - Greeks object
     */
    static calculateGreeks(S, K, T, r, sigma, optionType) {
        if (T <= 0) {
            return {
                delta: 0,
                gamma: 0,
                theta: 0,
                vega: 0,
                rho: 0
            };
        }

        const d1 = this.calculateD1(S, K, T, r, sigma);
        const d2 = this.calculateD2(d1, sigma, T);
        const nd1 = this.normalCDF(d1);
        const nd2 = this.normalCDF(d2);
        const npd1 = this.normalPDF(d1);

        let delta, theta, rho;
        
        if (optionType === 'call') {
            delta = nd1;
            theta = (-S * npd1 * sigma / (2 * Math.sqrt(T)) - r * K * Math.exp(-r * T) * nd2) / 365;
            rho = K * T * Math.exp(-r * T) * nd2 / 100;
        } else {
            delta = nd1 - 1;
            theta = (-S * npd1 * sigma / (2 * Math.sqrt(T)) + r * K * Math.exp(-r * T) * this.normalCDF(-d2)) / 365;
            rho = -K * T * Math.exp(-r * T) * this.normalCDF(-d2) / 100;
        }

        const gamma = npd1 / (S * sigma * Math.sqrt(T));
        const vega = S * npd1 * Math.sqrt(T) / 100;

        return {
            delta: delta,
            gamma: gamma,
            theta: theta,
            vega: vega,
            rho: rho
        };
    }

    /**
     * Calculate option price for a specific stock price
     * @param {Object} option - Option parameters
     * @param {number} stockPrice - Stock price to calculate for
     * @param {number} timeToExpiry - Time to expiry (in years)
     * @returns {number} - Option price
     */
    static getOptionPrice(option, stockPrice, timeToExpiry = null) {
        const T = timeToExpiry !== null ? timeToExpiry : option.timeToExpiry;
        
        if (option.type === 'call') {
            return this.callPrice(stockPrice, option.strike, T, option.riskFreeRate, option.volatility);
        } else {
            return this.putPrice(stockPrice, option.strike, T, option.riskFreeRate, option.volatility);
        }
    }

    /**
     * Calculate intrinsic value of an option
     * @param {string} optionType - 'call' or 'put'
     * @param {number} stockPrice - Current stock price
     * @param {number} strikePrice - Strike price
     * @returns {number} - Intrinsic value
     */
    static intrinsicValue(optionType, stockPrice, strikePrice) {
        if (optionType === 'call') {
            return Math.max(stockPrice - strikePrice, 0);
        } else {
            return Math.max(strikePrice - stockPrice, 0);
        }
    }

    /**
     * Calculate time value of an option
     * @param {number} optionPrice - Current option price
     * @param {string} optionType - 'call' or 'put'
     * @param {number} stockPrice - Current stock price
     * @param {number} strikePrice - Strike price
     * @returns {number} - Time value
     */
    static timeValue(optionPrice, optionType, stockPrice, strikePrice) {
        return optionPrice - this.intrinsicValue(optionType, stockPrice, strikePrice);
    }

    /**
     * Calculate implied volatility using Newton-Raphson method
     * @param {number} marketPrice - Market price of the option
     * @param {number} S - Current stock price
     * @param {number} K - Strike price
     * @param {number} T - Time to expiration (in years)
     * @param {number} r - Risk-free rate
     * @param {string} optionType - 'call' or 'put'
     * @returns {number} - Implied volatility
     */
    static impliedVolatility(marketPrice, S, K, T, r, optionType) {
        if (T <= 0) return 0;

        let sigma = 0.25; // Initial guess
        const tolerance = 1e-6;
        const maxIterations = 100;

        for (let i = 0; i < maxIterations; i++) {
            const price = optionType === 'call' 
                ? this.callPrice(S, K, T, r, sigma)
                : this.putPrice(S, K, T, r, sigma);
            
            const diff = price - marketPrice;
            
            if (Math.abs(diff) < tolerance) {
                return sigma;
            }

            // Calculate vega for Newton-Raphson
            const d1 = this.calculateD1(S, K, T, r, sigma);
            const vega = S * this.normalPDF(d1) * Math.sqrt(T);
            
            if (vega < 1e-6) break;
            
            sigma = sigma - diff / vega;
            
            // Keep sigma positive
            sigma = Math.max(sigma, 0.001);
        }

        return sigma;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = BlackScholes;
}
